use crate::error::{EnclaveError, Result};
use crate::types::WalletId;
use hkdf::Hkdf;
use sha2::Sha256;
use zeroize::Zeroizing;

// AWS Nitro NSM API for random number generation
#[cfg(feature = "nsm")]
use aws_nitro_enclaves_nsm_api::{api::Request, driver as nsm_driver};

const DB_ENCRYPTION_INFO: &[u8] = b"cashu-enclave-db-encryption-v1";
const SEED_SIZE: usize = 64; // BIP39 produces 512-bit seed

/// Seed manager for deriving keys and wallet ID
#[derive(Clone)]
pub struct SeedManager {
    /// The BIP39 seed (512 bits)
    seed: Zeroizing<[u8; SEED_SIZE]>,
    /// Wallet ID derived from seed hash
    wallet_id: WalletId,
    /// Database encryption key derived from seed
    db_encryption_key: Zeroizing<[u8; 32]>,
}

impl SeedManager {
    /// Generate a new seed using secure entropy source
    ///
    /// In NSM mode: Uses AWS Nitro Enclave's hardware random number generator
    /// In local mode: Uses OS random number generator (OsRng)
    pub fn generate_new() -> Result<Self> {
        tracing::info!("Generating new seed");

        let seed_bytes = Self::generate_random_seed()?;

        // Create seed manager from generated bytes
        Self::from_seed_bytes(&seed_bytes)
    }

    /// Generate random seed bytes using appropriate entropy source
    fn generate_random_seed() -> Result<[u8; SEED_SIZE]> {
        #[cfg(feature = "local-dev")]
        {
            tracing::info!("LOCAL DEV MODE: Generating seed using OsRng");
            use rand::RngCore;
            let mut seed = [0u8; SEED_SIZE];
            rand::rngs::OsRng.fill_bytes(&mut seed);
            return Ok(seed);
        }

        #[cfg(feature = "nsm")]
        {
            tracing::info!("NSM MODE: Generating seed using AWS Nitro NSM");

            // Open NSM device
            let nsm_fd = nsm_driver::nsm_init();

            // Request random bytes from NSM
            let request = Request::GetRandom;
            let response = nsm_driver::nsm_process_request(nsm_fd, request);
            nsm_driver::nsm_exit(nsm_fd);

            // Extract random bytes
            match response {
                aws_nitro_enclaves_nsm_api::api::Response::GetRandom { random } => {
                    // NSM returns up to 256 bytes of random data
                    // We need 64 bytes for the seed
                    if random.len() < SEED_SIZE {
                        return Err(EnclaveError::Crypto(format!(
                            "NSM returned insufficient random bytes: expected {}, got {}",
                            SEED_SIZE,
                            random.len()
                        )));
                    }

                    let mut seed = [0u8; SEED_SIZE];
                    seed.copy_from_slice(&random[..SEED_SIZE]);

                    tracing::info!("Successfully generated {} bytes of entropy from NSM", SEED_SIZE);
                    Ok(seed)
                }
                aws_nitro_enclaves_nsm_api::api::Response::Error(err) => {
                    Err(EnclaveError::Crypto(format!(
                        "NSM GetRandom failed: {:?}",
                        err
                    )))
                }
                _ => Err(EnclaveError::Crypto(
                    "Unexpected response from NSM GetRandom".to_string(),
                )),
            }
        }

        #[cfg(not(any(feature = "local-dev", feature = "nsm")))]
        {
            compile_error!("Either 'local-dev' or 'nsm' feature must be enabled");
        }
    }

    /// Create from decrypted seed bytes
    pub fn from_seed_bytes(seed_bytes: &[u8]) -> Result<Self> {
        if seed_bytes.len() != SEED_SIZE {
            return Err(EnclaveError::SeedDerivation(format!(
                "Invalid seed size: expected {}, got {}",
                SEED_SIZE,
                seed_bytes.len()
            )));
        }

        let mut seed = Zeroizing::new([0u8; SEED_SIZE]);
        seed.copy_from_slice(seed_bytes);

        // Derive wallet ID from seed hash
        let wallet_id = WalletId::from_seed(&seed[..]);

        // Derive database encryption key using HKDF
        let db_encryption_key = Self::derive_db_key(&seed)?;

        tracing::info!("Seed manager created for wallet_id: {}", wallet_id);

        Ok(Self {
            seed,
            wallet_id,
            db_encryption_key,
        })
    }

    /// Derive database encryption key from seed using HKDF-SHA256
    fn derive_db_key(seed: &[u8; SEED_SIZE]) -> Result<Zeroizing<[u8; 32]>> {
        let hkdf = Hkdf::<Sha256>::new(None, seed);
        let mut key = Zeroizing::new([0u8; 32]);

        hkdf.expand(DB_ENCRYPTION_INFO, &mut *key)
            .map_err(|e| EnclaveError::SeedDerivation(format!("HKDF expansion failed: {}", e)))?;

        Ok(key)
    }

    /// Get the wallet ID
    pub fn wallet_id(&self) -> WalletId {
        self.wallet_id
    }

    /// Get the database encryption key
    pub fn db_encryption_key(&self) -> &[u8; 32] {
        &self.db_encryption_key
    }

    /// Get the BIP39 seed (use with caution!)
    pub fn seed(&self) -> &[u8; SEED_SIZE] {
        &self.seed
    }
}

// Implement Drop to ensure secure cleanup
impl Drop for SeedManager {
    fn drop(&mut self) {
        tracing::debug!("Securely dropping SeedManager for wallet_id: {}", self.wallet_id);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_new() {
        // Test that we can generate a new seed
        let manager1 = SeedManager::generate_new().unwrap();
        let manager2 = SeedManager::generate_new().unwrap();

        // Different seeds should produce different wallet IDs
        assert_ne!(manager1.wallet_id(), manager2.wallet_id());

        // Different seeds should produce different DB keys
        assert_ne!(manager1.db_encryption_key(), manager2.db_encryption_key());
    }

    #[test]
    fn test_from_seed_bytes() {
        let seed = [42u8; 64];
        let manager = SeedManager::from_seed_bytes(&seed).unwrap();

        // Wallet ID should be deterministic
        let wallet_id1 = manager.wallet_id();

        // Create another manager with same seed
        let manager2 = SeedManager::from_seed_bytes(&seed).unwrap();
        let wallet_id2 = manager2.wallet_id();

        assert_eq!(wallet_id1, wallet_id2);

        // Encryption keys should match
        assert_eq!(manager.db_encryption_key(), manager2.db_encryption_key());
    }

    #[test]
    fn test_different_seeds_different_keys() {
        let seed1 = [42u8; 64];
        let seed2 = [43u8; 64];

        let manager1 = SeedManager::from_seed_bytes(&seed1).unwrap();
        let manager2 = SeedManager::from_seed_bytes(&seed2).unwrap();

        // Different wallet IDs
        assert_ne!(manager1.wallet_id(), manager2.wallet_id());

        // Different encryption keys
        assert_ne!(manager1.db_encryption_key(), manager2.db_encryption_key());
    }
}
